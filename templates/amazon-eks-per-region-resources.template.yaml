AWSTemplateFormatVersion: "2010-09-09"
Description: Shared resources required by all Amazon EKS Quick Start stacks in this region.
Parameters:
  QSS3BucketName:
    AllowedPattern: ^[0-9a-zA-Z]+([0-9a-zA-Z-]*[0-9a-zA-Z])*$
    ConstraintDescription: Quick Start bucket name can include numbers, lowercase
      letters, uppercase letters, and hyphens (-). It cannot start or end with a hyphen
      (-).
    Default: aws-quickstart
    Description: S3 bucket name for the Quick Start assets. This string can include
      numbers, lowercase letters, uppercase letters, and hyphens (-). It cannot start
      or end with a hyphen (-).
    Type: String
  QSS3KeyPrefix:
    AllowedPattern: ^[0-9a-zA-Z-/.]*$
    ConstraintDescription: Quick Start key prefix can include numbers, lowercase letters,
      uppercase letters, hyphens (-), dots(.) and forward slash (/).
    Default: quickstart-amazon-eks/
    Description: S3 key prefix for the Quick Start assets. Quick Start key prefix
      can include numbers, lowercase letters, uppercase letters, hyphens (-), dots(.) and
      forward slash (/).
    Type: String
  QSS3BucketRegion:
    Default: 'us-east-1'
    Description: The AWS Region where the Quick Start S3 bucket (QSS3BucketName) is
      hosted. When using your own bucket, you must specify this value.
    Type: String
Conditions:
  UsingDefaultBucket: !Equals [!Ref QSS3BucketName, 'aws-quickstart']
Mappings:
  Config:
    Prefix: { Value: 'eks-quickstart' }
Resources:
  LambdaZipsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub ['${Prefix}-lambdazips-${AWS::Region}-${AWS::AccountId}', {Prefix: !FindInMap [Config, Prefix, Value]}]
  CopyZipsRolePolicy:
    Type: AWS::IAM::Policy
    Properties:
      Roles: [!Sub ['${Prefix}-CopyZips', {Prefix: !FindInMap [Config, Prefix, Value]}]]
      PolicyName: !Sub ['${Prefix}-lambda-zip-bucket-access-${AWS::Region}', {Prefix: !FindInMap [Config, Prefix, Value]}]
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Action:
          - s3:PutObject
          - s3:DeleteObject
          Resource: !Sub 'arn:${AWS::Partition}:s3:::${LambdaZipsBucket}/${QSS3KeyPrefix}*'
  DeleteBucketContentsRolePolicy:
    Type: AWS::IAM::Policy
    Properties:
      Roles: [!Sub ['${Prefix}-DeleteBucketContents', {Prefix: !FindInMap [Config, Prefix, Value]}]]
      PolicyName: !Sub ['${Prefix}-delete-bucket-contents-${AWS::Region}', {Prefix: !FindInMap [Config, Prefix, Value]}]
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Action: 's3:*'
          Resource:
          - !Sub 'arn:${AWS::Partition}:s3:::${LambdaZipsBucket}/*'
          - !Sub 'arn:${AWS::Partition}:s3:::${LambdaZipsBucket}'
  CopyZipsFunction:
    Type: AWS::Lambda::Function
    DependsOn: CopyZipsRolePolicy
    Properties:
      FunctionName: !Sub ['${Prefix}-CopyZips', {Prefix: !FindInMap [Config, Prefix, Value]}]
      Description: Copies objects from a source S3 bucket to a destination
      Handler: index.handler
      Runtime: python3.7
      Role: !Sub ["arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${Prefix}-CopyZips", {Prefix: !FindInMap [Config, Prefix, Value]}]
      Timeout: 900
      Code:
        ZipFile: |
          import cfnresponse
          import logging
          import boto3
          logger = logging.getLogger(__name__)
          logger.setLevel(logging.DEBUG)
          def copy_objects(source_bucket, dest_bucket, prefix, objects):
              s3 = boto3.client('s3')
              for o in objects:
                  key = prefix + o
                  copy_source = {'Bucket': source_bucket, 'Key': key}
                  logging.info(f'copy_source: {copy_source}\ndest_bucket: {dest_bucket}\nkey: {key}')
                  s3.copy_object(CopySource=copy_source, Bucket=dest_bucket, Key=key)
          def delete_objects(bucket, prefix, objects):
              s3 = boto3.client('s3')
              objects = {'Objects': [{'Key': prefix + o} for o in objects]}
              try:
                  s3.delete_objects(Bucket=bucket, Delete=objects)
              except s3.exceptions.NoSuchBucket:
                  pass
          def handler(event, context):
              logger.debug(event)
              status = cfnresponse.SUCCESS
              try:
                  if event['RequestType'] == 'Delete':
                      delete_objects(event['ResourceProperties']['DestBucket'], event['ResourceProperties']['Prefix'],
                                     event['ResourceProperties']['Objects'])
                  else:
                      copy_objects(event['ResourceProperties']['SourceBucket'], event['ResourceProperties']['DestBucket'],
                                   event['ResourceProperties']['Prefix'], event['ResourceProperties']['Objects'])
              except Exception:
                  logging.error('Unhandled exception', exc_info=True)
                  status = cfnresponse.FAILED
              finally:
                  cfnresponse.send(event, context, status, {}, None)
  CopyZips:
    Type: Custom::CopyZips
    Properties:
      ServiceToken: !GetAtt 'CopyZipsFunction.Arn'
      DestBucket: !Ref LambdaZipsBucket
      SourceBucket: !If [UsingDefaultBucket, !Sub '${QSS3BucketName}-${AWS::Region}', !Ref QSS3BucketName]
      Prefix: !Ref 'QSS3KeyPrefix'
      Objects:
        - functions/packages/DeleteBucketContents/lambda.zip
        - functions/packages/KubeManifest/lambda.zip
        - functions/packages/CleanupLoadBalancers/lambda.zip
        - functions/packages/CleanupSecurityGroupDependencies/lambda.zip
        - functions/packages/CleanupLambdas/lambda.zip
        - functions/packages/kubectlLayer/lambda.zip
        - functions/packages/crhelperLayer/lambda.zip
        - functions/packages/GetCallerArn/lambda.zip
        - functions/packages/registerType/lambda.zip
        - functions/packages/registerCustomResource/lambda.zip
        - functions/packages/EksClusterResource/awsqs-eks-cluster.zip
        - functions/packages/HelmReleaseResource/awsqs-kubernetes-helm.zip
        - functions/packages/awscliLayer/lambda.zip
        - functions/packages/FargateProfile/lambda.zip
        - functions/packages/kubernetesResources/awsqs_kubernetes_get.zip
        - functions/packages/kubernetesResources/awsqs_kubernetes_get_vpc.zip
        - functions/packages/kubernetesResources/awsqs_kubernetes_apply.zip
        - functions/packages/kubernetesResources/awsqs_kubernetes_apply_vpc.zip
  ArtifactCopyPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref LambdaZipsBucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: Allow CloudFormation to copy artifacts from the bucket
            Effect: Allow
            Principal:
              Service: "cloudformation.amazonaws.com"
            Action:
              - s3:ListBucket
              - s3:GetObject
            Resource:
              - !Sub "arn:${AWS::Partition}:s3:::${LambdaZipsBucket}"
              - !Sub "arn:${AWS::Partition}:s3:::${LambdaZipsBucket}/${QSS3KeyPrefix}functions/packages/EksClusterResource/awsqs-eks-cluster.zip"
              - !Sub "arn:${AWS::Partition}:s3:::${LambdaZipsBucket}/${QSS3KeyPrefix}functions/packages/HelmReleaseResource/awsqs-kubernetes-helm.zip"
              - !Sub "arn:${AWS::Partition}:s3:::${LambdaZipsBucket}/${QSS3KeyPrefix}functions/packages/kubernetesResources/awsqs_kubernetes_get.zip"
              - !Sub "arn:${AWS::Partition}:s3:::${LambdaZipsBucket}/${QSS3KeyPrefix}functions/packages/kubernetesResources/awsqs_kubernetes_apply.zip"
  KubectlLayer:
    DependsOn: CopyZips
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: !Sub ['${Prefix}-Kubectl', {Prefix: !FindInMap [Config, Prefix, Value]}]
      Content:
        S3Bucket: !Ref LambdaZipsBucket
        S3Key: !Sub '${QSS3KeyPrefix}functions/packages/kubectlLayer/lambda.zip'
  AwsCliLayer:
    DependsOn: CopyZips
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: !Sub ['${Prefix}-AwsCli', {Prefix: !FindInMap [Config, Prefix, Value]}]
      Content:
        S3Bucket: !Ref LambdaZipsBucket
        S3Key: !Sub '${QSS3KeyPrefix}functions/packages/awscliLayer/lambda.zip'
  CrhelperLayer:
    DependsOn: CopyZips
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: !Sub ['${Prefix}-Crhelper', {Prefix: !FindInMap [Config, Prefix, Value]}]
      CompatibleRuntimes:
        - python3.6
        - python3.7
      Content:
        S3Bucket: !Ref LambdaZipsBucket
        S3Key: !Sub '${QSS3KeyPrefix}functions/packages/crhelperLayer/lambda.zip'
  CleanupLoadBalancersLambda:
    Type: "AWS::Lambda::Function"
    Properties:
      FunctionName: !Sub ['${Prefix}-CleanupLoadBalancers', {Prefix: !FindInMap [Config, Prefix, Value]}]
      Handler: lambda_function.lambda_handler
      MemorySize: 128
      Role: !Sub ["arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${Prefix}-CleanupLoadBalancers", {Prefix: !FindInMap [Config, Prefix, Value]}]
      Runtime: python3.7
      Timeout: 900
      Layers: [!Ref CrhelperLayer]
      Code:
        S3Bucket: !Sub ['${Prefix}-lambdazips-${AWS::Region}-${AWS::AccountId}', {Prefix: !FindInMap [Config, Prefix, Value]}]
        S3Key: !Sub '${QSS3KeyPrefix}functions/packages/CleanupLoadBalancers/lambda.zip'
  CleanupLambdasLambda:
    Type: "AWS::Lambda::Function"
    Properties:
      FunctionName: !Sub ['${Prefix}-CleanupLambdas', {Prefix: !FindInMap [Config, Prefix, Value]}]
      Handler: lambda_function.lambda_handler
      MemorySize: 128
      Role: !Sub ["arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${Prefix}-CleanupLambdas", {Prefix: !FindInMap [Config, Prefix, Value]}]
      Runtime: python3.7
      Timeout: 900
      Layers: [!Ref CrhelperLayer]
      Code:
        S3Bucket: !Sub ['${Prefix}-lambdazips-${AWS::Region}-${AWS::AccountId}', {Prefix: !FindInMap [Config, Prefix, Value]}]
        S3Key: !Sub '${QSS3KeyPrefix}functions/packages/CleanupLambdas/lambda.zip'
  RegisterTypeFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      FunctionName: !Sub ['${Prefix}-RegisterType', {Prefix: !FindInMap [Config, Prefix, Value]}]
      Handler: lambda_function.lambda_handler
      MemorySize: 128
      Role: !Sub ["arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${Prefix}-RegisterType", {Prefix: !FindInMap [Config, Prefix, Value]}]
      Layers: [!Ref CrhelperLayer]
      Runtime: python3.7
      Timeout: 900
      Code:
        S3Bucket: !Sub ['${Prefix}-lambdazips-${AWS::Region}-${AWS::AccountId}', {Prefix: !FindInMap [Config, Prefix, Value]}]
        S3Key: !Sub '${QSS3KeyPrefix}functions/packages/registerType/lambda.zip'
  RegisterCustomResourceFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      FunctionName: !Sub ['${Prefix}-RegisterCustomResource', {Prefix: !FindInMap [Config, Prefix, Value]}]
      Handler: lambda_function.lambda_handler
      MemorySize: 128
      Role: !Sub ["arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${Prefix}-RegisterCustomResource", {Prefix: !FindInMap [Config, Prefix, Value]}]
      Layers: [!Ref CrhelperLayer]
      Runtime: python3.7
      Timeout: 900
      Code:
        S3Bucket: !Sub ['${Prefix}-lambdazips-${AWS::Region}-${AWS::AccountId}', {Prefix: !FindInMap [Config, Prefix, Value]}]
        S3Key: !Sub '${QSS3KeyPrefix}functions/packages/registerCustomResource/lambda.zip'
  RegisterEksClusterType:
    DependsOn: ArtifactCopyPolicy
    Type: Custom::RegisterType
    Properties:
      ServiceToken: !GetAtt RegisterTypeFunction.Arn
      Version: "3.0.0-beta9"
      TypeName: "AWSQS::EKS::Cluster"
      SchemaHandlerPackage: !Sub ["s3://${Prefix}-lambdazips-${AWS::Region}-${AWS::AccountId}/${QSS3KeyPrefix}functions/packages/EksClusterResource/awsqs-eks-cluster.zip", {Prefix: !FindInMap [Config, Prefix, Value]}]
      IamPolicy:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Action:
          - "ec2:*"
          - "eks:CreateCluster"
          - "eks:DeleteCluster"
          - "eks:DescribeCluster"
          - "eks:ListClusters"
          - "eks:UpdateClusterConfig"
          - "eks:UpdateClusterVersion"
          - "iam:*"
          - "kms:*"
          - "lambda:*"
          Resource: "*"
  RegisterHelmType:
    DependsOn: ArtifactCopyPolicy
    Type: Custom::RegisterType
    Properties:
      ServiceToken: !GetAtt RegisterTypeFunction.Arn
      TypeName: "AWSQS::Kubernetes::Helm"
      Version: "3.0.0-beta9"
      SchemaHandlerPackage: !Sub ["s3://${Prefix}-lambdazips-${AWS::Region}-${AWS::AccountId}/${QSS3KeyPrefix}functions/packages/HelmReleaseResource/awsqs-kubernetes-helm.zip", {Prefix: !FindInMap [Config, Prefix, Value]}]
      IamPolicy:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Action:
          - "secretsmanager:GetSecretValue"
          - "kms:Decrypt"
          - "eks:DescribeCluster"
          - "s3:GetObject"
          - "sts:AssumeRole"
          - "iam:PassRole"
          - "iam:ListRolePolicies"
          - "iam:ListAttachedRolePolicies"
          - "iam:GetRole"
          - "iam:GetPolicy"
          - "iam:GetPolicyVersion"
          - "ec2:CreateNetworkInterface"
          - "ec2:DeleteNetworkInterface"
          - "ec2:Describe*"
          - "logs:CreateLogGroup"
          - "logs:CreateLogStream"
          - "logs:PutLogEvents"
          - "lambda:*"
          Resource: "*"
  RegisterKubeGetType:
    DependsOn: ArtifactCopyPolicy
    Type: Custom::RegisterType
    Properties:
      ServiceToken: !GetAtt RegisterTypeFunction.Arn
      TypeName: "AWSQS::Kubernetes::Get"
      Version: "3.0.0-beta9"
      SchemaHandlerPackage: !Sub ["s3://${Prefix}-lambdazips-${AWS::Region}-${AWS::AccountId}/${QSS3KeyPrefix}functions/packages/kubernetesResources/awsqs_kubernetes_get.zip", {Prefix: !FindInMap [Config, Prefix, Value]}]
      IamPolicy:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action: [
              "ec2:CreateNetworkInterface",
              "ec2:DeleteNetworkInterface",
              "ec2:Describe*",
              "eks:DescribeCluster",
              "iam:PassRole",
              "lambda:*",
              "ssm:GetParameter",
              "sts:GetCallerIdentity",
              "logs:CreateLogGroup",
              "logs:CreateLogStream",
              "logs:PutLogEvents"
            ]
            Resource: "*"
  RegisterKubeApplyType:
    DependsOn: ArtifactCopyPolicy
    Type: Custom::RegisterType
    Properties:
      ServiceToken: !GetAtt RegisterTypeFunction.Arn
      TypeName: "AWSQS::Kubernetes::Resource"
      Version: "3.0.0-beta11"
      SchemaHandlerPackage: !Sub ["s3://${Prefix}-lambdazips-${AWS::Region}-${AWS::AccountId}/${QSS3KeyPrefix}functions/packages/kubernetesResources/awsqs_kubernetes_apply.zip", {Prefix: !FindInMap [Config, Prefix, Value]}]
      IamPolicy:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action: [
              "ec2:CreateNetworkInterface",
              "ec2:DeleteNetworkInterface",
              "ec2:Describe*",
              "eks:DescribeCluster",
              "iam:PassRole",
              "lambda:*",
              "ssm:GetParameter",
              "sts:GetCallerIdentity",
              "logs:CreateLogGroup",
              "logs:CreateLogStream",
              "logs:PutLogEvents"
            ]
            Resource: "*"
  CleanupSecurityGroupDependenciesLambda:
    Type: "AWS::Lambda::Function"
    Properties:
      FunctionName: !Sub ['${Prefix}-CleanupSecurityGroupDependencies', {Prefix: !FindInMap [Config, Prefix, Value]}]
      Handler: lambda_function.lambda_handler
      MemorySize: 128
      Role: !Sub ["arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${Prefix}-CleanupSecurityGroupDependencies", {Prefix: !FindInMap [Config, Prefix, Value]}]
      Layers: [!Ref CrhelperLayer]
      Runtime: python3.7
      Timeout: 900
      Code:
        S3Bucket: !Sub ['${Prefix}-lambdazips-${AWS::Region}-${AWS::AccountId}', {Prefix: !FindInMap [Config, Prefix, Value]}]
        S3Key: !Sub '${QSS3KeyPrefix}functions/packages/CleanupSecurityGroupDependencies/lambda.zip'
  DeleteBucketContentsLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ['${Prefix}-DeleteBucketContents', {Prefix: !FindInMap [Config, Prefix, Value]}]
      Handler: lambda_function.lambda_handler
      MemorySize: 128
      Role: !Sub ["arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${Prefix}-DeleteBucketContents", {Prefix: !FindInMap [Config, Prefix, Value]}]
      Runtime: python3.7
      Timeout: 900
      Layers: [!Ref 'CrhelperLayer']
      Code:
        S3Bucket: !Sub ['${Prefix}-lambdazips-${AWS::Region}-${AWS::AccountId}', {Prefix: !FindInMap [Config, Prefix, Value]}]
        S3Key: !Sub '${QSS3KeyPrefix}functions/packages/DeleteBucketContents/lambda.zip'
  GetCallerArnLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ['${Prefix}-GetCallerArn', {Prefix: !FindInMap [Config, Prefix, Value]}]
      Handler: lambda_function.lambda_handler
      MemorySize: 128
      Role: !Sub ["arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${Prefix}-GetCallerArn", {Prefix: !FindInMap [Config, Prefix, Value]}]
      Runtime: python3.7
      Timeout: 900
      Layers: [!Ref 'CrhelperLayer']
      Code:
        S3Bucket: !Sub ['${Prefix}-lambdazips-${AWS::Region}-${AWS::AccountId}', {Prefix: !FindInMap [Config, Prefix, Value]}]
        S3Key: !Sub '${QSS3KeyPrefix}functions/packages/GetCallerArn/lambda.zip'
  NodeSGFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ['${Prefix}-NodeSG', {Prefix: !FindInMap [Config, Prefix, Value]}]
      Description: Fetches the Security Group ID for a given EKS Managed Node Group
      Handler: index.handler
      Runtime: python3.7
      Role:  !Sub ["arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${Prefix}-NodeSG", {Prefix: !FindInMap [Config, Prefix, Value]}]
      Timeout: 900
      Layers: [!Ref 'CrhelperLayer']
      Code:
        ZipFile: |
          import logging
          import boto3
          from crhelper import CfnResource

          logger = logging.getLogger(__name__)
          helper = CfnResource(json_logging=True, log_level='DEBUG')

          try:
              eks_client = boto3.client('eks')
          except Exception as init_exception:
              helper.init_failure(init_exception)

          @helper.create
          @helper.update
          def create(event, _):
              response = eks_client.describe_nodegroup(
                  clusterName=event['ResourceProperties']['ClusterName'],
                  nodegroupName=event['ResourceProperties']['NodeGroupName']
              )
              return response['nodegroup']['resources']['remoteAccessSecurityGroup']

          def handler(event, context):
              helper(event, context)
  FargateProfileLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ['${Prefix}-FargateProfile', {Prefix: !FindInMap [Config, Prefix, Value]}]
      Handler: lambda_function.lambda_handler
      MemorySize: 128
      Role: !Sub ["arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${Prefix}-FargateProfile", {Prefix: !FindInMap [Config, Prefix, Value]}]
      Runtime: python3.7
      Timeout: 900
      Layers: [!Ref 'CrhelperLayer']
      Code:
        S3Bucket: !Sub ['${Prefix}-lambdazips-${AWS::Region}-${AWS::AccountId}', {Prefix: !FindInMap [Config, Prefix, Value]}]
        S3Key: !Sub '${QSS3KeyPrefix}functions/packages/FargateProfile/lambda.zip'
  ResourceReaderFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ['arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${Prefix}-ResourceReader', {Prefix: !FindInMap [Config, Prefix, Value]}]
      Description: Performs an AWS CLI command and returns the json result. Used to get the state of existing resources.
      Handler: index.handler
      Runtime: python3.7
      Role: !Sub ["arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${Prefix}-ResourceReader", {Prefix: !FindInMap [Config, Prefix, Value]}]
      Timeout: 900
      Code:
        ZipFile: |
          import cfnresponse
          from urllib.request import Request, urlopen
          from urllib.error import URLError
          import shutil
          import tempfile
          import logging
          from zipfile import ZipFile
          import subprocess
          import shlex
          from pathlib import Path
          import json

          logger = logging.getLogger(__name__)
          logger.setLevel(logging.DEBUG)
          message = ''
          code = ''
          cli = ''
          if Path("/tmp/bin/aws").is_file():
              cli = '/tmp/bin/aws'

          def run_command(command):
              code = 0
              try:
                  logger.debug("executing command: %s" % command)
                  output = subprocess.check_output(shlex.split(command), stderr=subprocess.STDOUT).decode("utf-8")
                  logging.debug(output)
              except subprocess.CalledProcessError as exc:
                  code = exc.returncode
                  output = exc.output.decode("utf-8")
                  logger.error("Command failed [exit %s]: %s" % (exc.returncode, exc.output.decode("utf-8")))
              return code, output


          if not cli:
              req = Request("https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip")
              try:
                  with urlopen(req) as response:
                     with tempfile.NamedTemporaryFile(delete=False) as tmp_file:
                          shutil.copyfileobj(response, tmp_file)
                  with ZipFile(tmp_file.name) as zip:
                      zip.extractall('/tmp/cli-install/')
                  run_command('chmod +x /tmp/cli-install/aws/dist/aws')
                  run_command('chmod +x /tmp/cli-install/aws/install')
                  c, _ = run_command('/tmp/cli-install/aws/install -b /tmp/bin -i /tmp/aws-cli')
                  if c == 0:
                      cli = '/tmp/bin/aws'
              except URLError as e:
                  if hasattr(e, 'reason'):
                      logger.error('Fetching url failed: ', e.reason)
                      message = e.reason
                  elif hasattr(e, 'code'):
                      logger.error('Error code: ', e.code)
                      code = e.code


          def execute_cli(properties):
              if not cli:
                  pass
              code, response = run_command(f"{cli} {properties['AwsCliCommand']} --output json")
              if code != 0 and ('NotFound' in response or 'does not exist' in response):
                  return None
              if code != 0:
                  raise Exception(response)
              return json.loads(response)


          def handler(event, context):
              logger.debug(event)
              status = cfnresponse.SUCCESS
              pid = 'None'
              resp = {}
              try:
                  if event['RequestType'] != 'Delete':
                      resp = execute_cli(event['ResourceProperties'])
                      if 'IdField' in event['ResourceProperties'] and isinstance(resp, dict):
                          pid = resp[event['ResourceProperties']['IdField']]
                      else:
                          pid = str(resp)
              except Exception:
                  logging.error('Unhandled exception', exc_info=True)
                  status = cfnresponse.FAILED
              finally:
                  cfnresponse.send(event, context, status, resp, pid)
  ParameterResolverFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: 'QuickStart-ParameterResolver'
      Code:
        ZipFile: |
          import traceback
          import json
          import re
          import boto3
          from functools import partial


          def template_iterator(obj, params, ssm, prefix):
              if isinstance(obj, dict):
                  for k in obj:
                      obj[k] = template_iterator(obj[k], params, ssm, prefix)
              elif isinstance(obj, list):
                  for i, v in enumerate(obj):
                      obj[i] = template_iterator(v, params, ssm, prefix)
              elif isinstance(obj, str):
                  func = partial(resolver, ssm, prefix, params['params'])
                  obj = re.sub(r'~~[\w/<>]+~~', func, obj)
              return obj


          def resolver(ssm, prefix, params, match):
              default = None
              param = match.group()[2:-2]
              if param.startswith('%'):
                  return match.group()
              if '|' in param:
                  default = ''.join(param.split('|')[1:])
                  param = param.split('|')[0]
              func = partial(param_resolve, params)
              param = re.sub(r'<\w+>', func, param)
              try:
                  resp = ssm.get_parameter(Name=prefix + param)
                  return json.loads(resp['Parameter']['Value'])['Value']
              except ssm.exceptions.ParameterNotFound:
                  if default is None:
                      raise Exception(f"Parameter {param} not found")
                  return default


          def param_resolve(params, match):
              return params[match.group()[1:-1]]


          def handler(event, _c):
              print(json.dumps(event))
              macro_response = {
                  "requestId": event["requestId"],
                  "status": "success"
              }
              try:
                  ssm = boto3.client('ssm', region_name=event["region"])
                  params = {
                      "params": event["templateParameterValues"],
                      "template": event["fragment"],
                      "account_id": event["accountId"],
                      "region": event["region"]
                  }
                  response = event["fragment"]
                  prefix = params['template'].get('Mappings',{}).get('Config',{}).get('ParameterPrefix',{}).get('Value',"")
                  macro_response["fragment"] = template_iterator(response, params, ssm, prefix)
              except Exception as e:
                  traceback.print_exc()
                  macro_response["status"] = "failure"
                  macro_response["errorMessage"] = str(e)
              print(json.dumps(macro_response))
              return macro_response
      Handler: index.handler
      Runtime: python3.7
      Role: !Sub ["arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${Prefix}-ParameterResolver", {Prefix: !FindInMap [Config, Prefix, Value]}]
  ParameterResolverFunctionPermissions:
    Type: AWS::Lambda::Permission
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !GetAtt ParameterResolverFunction.Arn
      Principal: 'cloudformation.amazonaws.com'
  ParameterResolver:
    Type: AWS::CloudFormation::Macro
    Properties:
      Name: 'QuickStartParameterResolver'
      Description: Resolves ssm parameters in templates
      FunctionName: !GetAtt ParameterResolverFunction.Arn
